"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapSchema = exports.getMapProxy = void 0;
var ChangeTree_1 = require("../changes/ChangeTree");
var spec_1 = require("../spec");
var utils_1 = require("./utils");
function getMapProxy(value) {
    value['$proxy'] = true;
    value = new Proxy(value, {
        get: function (obj, prop) {
            if (typeof (prop) !== "symbol" && // accessing properties
                typeof (obj[prop]) === "undefined") {
                return obj.get(prop);
            }
            else {
                return obj[prop];
            }
        },
        set: function (obj, prop, setValue) {
            if (typeof (prop) !== "symbol" &&
                (prop.indexOf("$") === -1 &&
                    prop !== "onAdd" &&
                    prop !== "onRemove" &&
                    prop !== "onChange")) {
                obj.set(prop, setValue);
            }
            else {
                obj[prop] = setValue;
            }
            return true;
        },
        deleteProperty: function (obj, prop) {
            obj.delete(prop);
            return true;
        },
    });
    return value;
}
exports.getMapProxy = getMapProxy;
var MapSchema = /** @class */ (function () {
    function MapSchema(initialValues) {
        var _this = this;
        this.$changes = new ChangeTree_1.ChangeTree(this);
        this.$items = new Map();
        this.$indexes = new Map();
        this.$refId = 0;
        if (initialValues) {
            if (initialValues instanceof Map) {
                initialValues.forEach(function (v, k) { return _this.set(k, v); });
            }
            else {
                for (var k in initialValues) {
                    this.set(k, initialValues[k]);
                }
            }
        }
    }
    MapSchema.prototype.onAdd = function (callback, triggerAll) {
        if (triggerAll === void 0) { triggerAll = true; }
        return utils_1.addCallback((this.$callbacks || (this.$callbacks = [])), spec_1.OPERATION.ADD, callback, (triggerAll)
            ? this.$items
            : undefined);
    };
    MapSchema.prototype.onRemove = function (callback) { return utils_1.addCallback(this.$callbacks || (this.$callbacks = []), spec_1.OPERATION.DELETE, callback); };
    MapSchema.prototype.onChange = function (callback) { return utils_1.addCallback(this.$callbacks || (this.$callbacks = []), spec_1.OPERATION.REPLACE, callback); };
    MapSchema.is = function (type) {
        return type['map'] !== undefined;
    };
    /** Iterator */
    MapSchema.prototype[Symbol.iterator] = function () { return this.$items[Symbol.iterator](); };
    Object.defineProperty(MapSchema.prototype, Symbol.toStringTag, {
        get: function () { return this.$items[Symbol.toStringTag]; },
        enumerable: false,
        configurable: true
    });
    MapSchema.prototype.set = function (key, value) {
        if (value === undefined || value === null) {
            throw new Error("MapSchema#set('" + key + "', " + value + "): trying to set " + value + " value on '" + key + "'.");
        }
        // get "index" for this value.
        var hasIndex = typeof (this.$changes.indexes[key]) !== "undefined";
        var index = (hasIndex)
            ? this.$changes.indexes[key]
            : this.$refId++;
        var operation = (hasIndex)
            ? spec_1.OPERATION.REPLACE
            : spec_1.OPERATION.ADD;
        var isRef = (value['$changes']) !== undefined;
        if (isRef) {
            value['$changes'].setParent(this, this.$changes.root, index);
        }
        //
        // (encoding)
        // set a unique id to relate directly with this key/value.
        //
        if (!hasIndex) {
            this.$changes.indexes[key] = index;
            this.$indexes.set(index, key);
        }
        else if (isRef && // if is schema, force ADD operation if value differ from previous one.
            this.$items.get(key) !== value) {
            operation = spec_1.OPERATION.ADD;
        }
        this.$items.set(key, value);
        this.$changes.change(key, operation);
        return this;
    };
    MapSchema.prototype.get = function (key) {
        return this.$items.get(key);
    };
    MapSchema.prototype.delete = function (key) {
        //
        // TODO: add a "purge" method after .encode() runs, to cleanup removed `$indexes`
        //
        // We don't remove $indexes to allow setting the same key in the same patch
        // (See "should allow to remove and set an item in the same place" test)
        //
        // // const index = this.$changes.indexes[key];
        // // this.$indexes.delete(index);
        this.$changes.delete(key);
        return this.$items.delete(key);
    };
    MapSchema.prototype.clear = function (changes) {
        // discard previous operations.
        this.$changes.discard(true, true);
        this.$changes.indexes = {};
        // clear previous indexes
        this.$indexes.clear();
        //
        // When decoding:
        // - enqueue items for DELETE callback.
        // - flag child items for garbage collection.
        //
        if (changes) {
            utils_1.removeChildRefs.call(this, changes);
        }
        // clear items
        this.$items.clear();
        this.$changes.operation({ index: 0, op: spec_1.OPERATION.CLEAR });
        // touch all structures until reach root
        this.$changes.touchParents();
    };
    MapSchema.prototype.has = function (key) {
        return this.$items.has(key);
    };
    MapSchema.prototype.forEach = function (callbackfn) {
        this.$items.forEach(callbackfn);
    };
    MapSchema.prototype.entries = function () {
        return this.$items.entries();
    };
    MapSchema.prototype.keys = function () {
        return this.$items.keys();
    };
    MapSchema.prototype.values = function () {
        return this.$items.values();
    };
    Object.defineProperty(MapSchema.prototype, "size", {
        get: function () {
            return this.$items.size;
        },
        enumerable: false,
        configurable: true
    });
    MapSchema.prototype.setIndex = function (index, key) {
        this.$indexes.set(index, key);
    };
    MapSchema.prototype.getIndex = function (index) {
        return this.$indexes.get(index);
    };
    MapSchema.prototype.getByIndex = function (index) {
        return this.$items.get(this.$indexes.get(index));
    };
    MapSchema.prototype.deleteByIndex = function (index) {
        var key = this.$indexes.get(index);
        this.$items.delete(key);
        this.$indexes.delete(index);
    };
    MapSchema.prototype.toJSON = function () {
        var map = {};
        this.forEach(function (value, key) {
            map[key] = (typeof (value['toJSON']) === "function")
                ? value['toJSON']()
                : value;
        });
        return map;
    };
    //
    // Decoding utilities
    //
    MapSchema.prototype.clone = function (isDecoding) {
        var cloned;
        if (isDecoding) {
            // client-side
            cloned = Object.assign(new MapSchema(), this);
        }
        else {
            // server-side
            cloned = new MapSchema();
            this.forEach(function (value, key) {
                if (value['$changes']) {
                    cloned.set(key, value['clone']());
                }
                else {
                    cloned.set(key, value);
                }
            });
        }
        return cloned;
    };
    return MapSchema;
}());
exports.MapSchema = MapSchema;
//# sourceMappingURL=MapSchema.js.map