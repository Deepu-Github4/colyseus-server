"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
var types_1 = require("../types");
var typeMaps = {
    "string": "string",
    "number": "float",
    "boolean": "bool",
    "int8": "sbyte",
    "uint8": "byte",
    "int16": "short",
    "uint16": "ushort",
    "int32": "int",
    "uint32": "uint",
    "int64": "long",
    "uint64": "ulong",
    "float32": "float",
    "float64": "double",
};
/**
 * C# Code Generator
 */
var capitalize = function (s) {
    if (typeof s !== 'string')
        return '';
    return s.charAt(0).toUpperCase() + s.slice(1);
};
function generate(context, options) {
    return __spreadArray(__spreadArray([], __read(context.classes.map(function (structure) { return ({
        name: structure.name + ".cs",
        content: generateClass(structure, options.namespace)
    }); }))), __read(context.interfaces.map(function (structure) { return ({
        name: structure.name + ".cs",
        content: generateInterface(structure, options.namespace)
    }); })));
}
exports.generate = generate;
function generateClass(klass, namespace) {
    var indent = (namespace) ? "\t" : "";
    return types_1.getCommentHeader() + "\n\nusing Colyseus.Schema;\nusing Action = System.Action;\n" + (namespace ? "\nnamespace " + namespace + " {" : "") + "\n" + indent + "public partial class " + klass.name + " : " + klass.extends + " {\n" + klass.properties.map(function (prop) { return generateProperty(prop, indent); }).join("\n\n") + "\n\n" + indent + "\t/*\n" + indent + "\t * Support for individual property change callbacks below...\n" + indent + "\t */\n\n" + generateAllFieldCallbacks(klass, indent) + "\n" + indent + "}\n" + (namespace ? "}" : "") + "\n";
}
function generateProperty(prop, indent) {
    if (indent === void 0) { indent = ""; }
    var typeArgs = "\"" + prop.type + "\"";
    var property = "public";
    var langType;
    var initializer = "";
    if (prop.childType) {
        var isUpcaseFirst = prop.childType.match(/^[A-Z]/);
        langType = getType(prop);
        typeArgs += ", typeof(" + langType + ")";
        if (!isUpcaseFirst) {
            typeArgs += ", \"" + prop.childType + "\"";
        }
        initializer = "new " + langType + "()";
    }
    else {
        langType = getType(prop);
        initializer = "default(" + langType + ")";
    }
    property += " " + langType + " " + prop.name;
    var ret = (prop.deprecated) ? "\t\t[System.Obsolete(\"field '" + prop.name + "' is deprecated.\", true)]\n" : '';
    return ret + ("\t" + indent + "[Type(" + prop.index + ", " + typeArgs + ")]\n\t" + indent + property + " = " + initializer + ";");
}
function generateInterface(struct, namespace) {
    var indent = (namespace) ? "\t" : "";
    return types_1.getCommentHeader() + "\n\nusing Colyseus.Schema;\n" + (namespace ? "\nnamespace " + namespace + " {" : "") + "\n" + indent + "public class " + struct.name + " {\n" + struct.properties.map(function (prop) { return "\t" + indent + "public " + getType(prop) + " " + prop.name + ";"; }).join("\n") + "\n" + indent + "}\n" + (namespace ? "}" : "") + "\n";
}
function generateAllFieldCallbacks(klass, indent) {
    //
    // TODO: improve me. It would be great to generate less boilerplate in favor
    // of a single implementation on C# Schema class itself.
    //
    var eventNames = [];
    return klass.properties.map(function (prop) {
        var eventName = "_" + prop.name + "Change";
        eventNames.push(eventName);
        return "\t" + indent + "protected event PropertyChangeHandler<" + getType(prop) + "> " + eventName + ";\n\t" + indent + "public Action On" + capitalize(prop.name) + "Change(PropertyChangeHandler<" + getType(prop) + "> handler) {\n\t" + indent + "\tif (__callbacks == null) { __callbacks = new SchemaCallbacks(); }\n\t" + indent + "\t__callbacks.AddPropertyCallback(nameof(" + prop.name + "));\n\t" + indent + "\t" + eventName + " += handler;\n\t" + indent + "\treturn () => {\n\t" + indent + "\t\t__callbacks.RemovePropertyCallback(nameof(" + prop.name + "));\n\t" + indent + "\t\t" + eventName + " -= handler;\n\t" + indent + "\t};\n\t" + indent + "}";
    }).join("\n\n") + "\n\n\t" + indent + "protected override void TriggerFieldChange(DataChange change) {\n\t" + indent + "\tswitch (change.Field) {\n" + klass.properties.map(function (prop, i) {
        return "\t" + indent + "\t\tcase nameof(" + prop.name + "): " + eventNames[i] + "?.Invoke((" + getType(prop) + ") change.Value, (" + getType(prop) + ") change.PreviousValue); break;";
    }).join("\n") + "\n\t" + indent + "\t\tdefault: break;\n\t\t" + indent + "}\n\t" + indent + "}";
}
function getChildType(prop) {
    return typeMaps[prop.childType];
}
function getType(prop) {
    if (prop.childType) {
        var isUpcaseFirst = prop.childType.match(/^[A-Z]/);
        var type = void 0;
        if (prop.type === "ref") {
            type = (isUpcaseFirst)
                ? prop.childType
                : getChildType(prop);
        }
        else {
            var containerClass = capitalize(prop.type);
            type = (isUpcaseFirst)
                ? containerClass + "Schema<" + prop.childType + ">"
                : containerClass + "Schema<" + getChildType(prop) + ">";
        }
        return type;
    }
    else {
        return (prop.type === "array")
            ? (typeMaps[prop.childType] || prop.childType) + "[]"
            : typeMaps[prop.type];
    }
}
//# sourceMappingURL=csharp.js.map